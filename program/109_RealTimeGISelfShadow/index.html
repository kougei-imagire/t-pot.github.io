<head>
	<title>t-pot『自己遮蔽項付きリアルタイム大域照明』</title>
	<link rel="stylesheet" type="text/css" href="../if.css">
</head>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<body>


<div class="contents">
<center>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<h1>自己遮蔽項付きリアルタイム大域照明</h1><br>
<h3>～ Real-Time Global Illumination with self shadows ～</h3>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<image src = "title.png">
<br>
<hr>
</center>
<div>


<h2>■はじめに</h2>


<p>
前回、リアルタイム大域照明を取り扱いました。<br>
これは、入射光を環境マップとして取り込んで、それらを球面調和関数展開することによって、拡散光をより正確に表現する手法です。<br>
今回は、さらにPRTを併用して、自己遮蔽つきのリアルタイム大域照明を実装してみました。
</p>

<p>
で、いつものようにプログラムです。<br>
</p>
<ul style = "LIST-STYLE-TYPE:none">
<li><a href="src.zip">src.zip (自己遮蔽項付きリアルタイム大域照明:DirectX9 [Vertex shader 1_1, Pixel shader 2_0, 浮動小数点バッファ使用])</a>
</ul>
<p>
GeForce FX では、PRTテクスチャを作成する工程で浮動小数点バッファを使うためにHALで動かないのですが、あらかじめテクスチャを用意しておけば高速に動作するので、私が作成したPRTテクスチャを読み込んで実行するGeForce FX 用のプログラムも用意しておきました。
</p>
<p>
カーソルキーで、カメラが回って、zやxでズームが変えられます。<br>
また、aキーで「全照明効果」、「環境マップなし」、「環境マップのみ」の切り替えができます。<br>
pキーでティーポットの動きを止めることができます。
</p>
<p>
上の画像は、下のように拡散光と環境マップが合成されて最終的な出力になっています。
</p>
<image src = "GI.png"> + <image src = "envmap.png"> = <image src = "final.png">
<p>
ソースには、いつものように適当にファイルが入っています。
大事なファイルは次のものです。
</p>
<table>
<tr><td><a href="main_h.html">main.h</a></td><td>アプリケーションのヘッダ</td></tr>
<tr><td><a href="main_cpp.html">main.cpp</a></td><td>アプリケーションのソース</td></tr>
<tr><td><a href="hlsl_fx.html">hlsl.fx</a></td><td>シェーダプログラム</td></tr>
<tr><td><a href="paraboloid_fx.html">paraboloid.fx</a></td><td>Dual paraboloid マップのためのシェーダ</td></tr>
</table>


<h2>■何をやっているの</h2>


<p>
前回は、オブジェクトに入射する光のレンダリング方程式
</p>
<image src = "eq1.png">
<p>
の入射光L<sub>i</sub>に関して、SH展開をしました。<br>
今回は、このレンダリング方程式を２つの項に分解します。
</p>
<image src = "eq6.png">
<p>
このV(x,ω<sub>i</sub>)は遮蔽項と呼ばれる項で、外部から入射した光が自分のほかの部分にさえぎられて届かなかったら0、届いたら1となるような関数です。<br>
遮蔽項によるレンダリング方程式の分離は、「外部から届いた光の項」と「光が自分の別の部分にあたって、その光が反射した項」の意味で入射光を分類したように取ることができます。<br>
ここで、「光が自分の別の部分にあたって、その光が反射した項」は、一度光が反射してから届くので、「拡散光は反射率は小さくその効果は小さい」、「反射光は非常にまれにしか反射しないので、ほとんどの場合無視することができる」と理由で、これらの項を無視すると、レンだリング方程式は、
</p>
<image src = "eq7.png">
<p>
と近似することができます（もちろん、この近似が成り立たない場合もあります。そのときには、今回の方法は使えません）。<br>
この関数に関して、入射光を球面調和関数展開
</p>
<image src = "eq2.png">
<p>
すると、次のような式に変形できます。
</p>
<image src = "eq3.png">
<p>
</p>
<image src = "eq4.png">
<p>
ここで、A<sub>lm</sub>は、次のような係数です。
</p>
<image src = "eq5.png">
<p>
これらの式を見ると、今回は、前回と係数 A<sub>lm</sub>だけが異なるということが分かります。<br>
係数の違いは、遮蔽項があるかないかということです。前回は遮蔽項が無かったので、係数 A<sub>lm</sub>はモデルの法線だけにしか依存していなかったのですが、今回は、法線ベクトルとレンダレングする位置に依存します。但し、法線ベクトルはレンダリングする位置だけによるので、実際には、レンダリングする位置だけによるということになります。<br>
しかも、この係数はPRTのSH展開の係数に他なりません。そこで、前回はスフィアマップで求めた A<sub>lm</sub> を、模様を描いたデカールのテクスチャと同じ構造をもったテクスチャに焼き付け、デカールのテクスチャ座標を使って、係数 A<sub>lm</sub> を張り込みます。
</p>
<p>
今回用意したテクスチャは、次のものです。
</p>
<image src = "texture.png">
<p>
自分でテクスチャを張り込んだのですが、きれいに張れていないのは勘弁してください。
</p>
<p>
レンダリングの工程では、最初に、このテクスチャがレンダリングされる座標を調べます。<br>
これは、レンダリング先をテクスチャ座標にあわせて、位置座標をレンダリングされる色にしてレンダリングします。
適当にスケールをあわせると次のようになります。
</p>
<image src = "position.png">
<p>
同じように、法線マップも作成します。
</p>
<image src = "normal.png">
<p>
次に、レンダリングしたテクセルごとに、レンダリングされる位置と法線方向の向きにカメラを置いて、モデルを描画します。<br>
すると、自分が描画された位置から、外部の光がさえぎられるかわかるので、その情報を元に係数をレンダリングします。<br>
実際に作成するシーンは次のようになります。
</p>
<image src = "PreComputing.png">
<p>
テクスチャを１つずつ走査して、スフィアマップの様に自分をレンダリングして、さらにSH係数を掛けることによって、被積分関数をもとめ、あとは６４ボックスサンプリングで、１テクセルの情報まで落としこみます。<br>
なお、x成分にSH(1,-1)、y成分にSH(1,0)、z成分にSH(1,1)、w成分にSH(0,0)の成分を埋め込んでいるので、今回は極彩色のグラデーションが見れると思います(今回は、２次以上の高次の計算は面倒くさいのでしていません)。<br>
最終的な画像は次の様になります。
</p>
<image src = "PRT.png">
<p>
浮動小数点バッファがつかえない環境では、上のテクスチャを読み込んで、レンダリングの時に使えば、実行することができます。
</p>

<p>
描画方法とかは前と一緒なので省略～
</p>


<h2>■最後に</h2>


<p>
これなら、実用になるものだと思うのですが、いかがでしょうか。
</p>
<p>
それにしても、このモデルは、ティーポットのテクスチャの継ぎ目が分かってしまうので、きちんとしたモデルを準備したいですね。
</p>




</div>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<center>
<hr>
<p><a href="../index.html">もどる</a></p>
<p><a href="mailto:imagire@gmail.com">imagire@gmail.com</a></p>
</center>

</body>
</html>