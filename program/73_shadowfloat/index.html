<head>
	<title>t-pot『浮動小数点数バッファ影』</title>
	<link rel="stylesheet" type="text/css" href="../if.css">
</head>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<body>


<div class="contents">
<center>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<h1>浮動小数点数バッファ影</h1><br>
<h3>～ IEEE format shadow map ～</h3>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<image src = "title.jpg">
<br>
<hr>
</center>
<div>


<h2>■はじめに</h2>


<p>
DirectX9 の新しい機能を使ってみましょう。<br>
今回使ったのは、D3DFMT_R32F で、赤色成分に３２ビット浮動小数点数を使います。<br>
このフォーマットを使って固定機能でテクスチャを表示すると、他の成分には255が入って表示されます（左上の画像がそれです）。<br>
シャドウマップでテクスチャフォーマットを浮動小数点数にしてみました。<br>
結果からいうと、今回は失敗です。R8G8B8A8 と見た目が変わりませんでした。
ATI のデモのように、マルチサンプリングしてソフトシャドウにしていかないと違いが出ないかもしれません。<br>
今回の見た目がきれいなのはシャドウマップのサイズが大きいからです。2048x2048x2(FB+Z)の32メガバイトのメモリを使っています。
これだけ使うと、パフォーマンスが非常に下がりますね。512x512 だと、270 FPS でたところが、2048x2048 だと、136 FPS に下がりました。
</p>
<p>
下のファイルがソースと実行ファイルです。<br>
カーソルキーで上下左右に動かせますし、Z,Xでズームイン、アウトができます。
</p>
<ul style = "LIST-STYLE-TYPE:none">
<li><a href="src.lzh">src.lzh (浮動小数点数バッファ影:DirectX9)</a>
</ul>

<p>
まぁ、いつものように適当にファイルが入っています。<br>
ほとんどが APP WIZARD から出力されるファイルです。<br>
以下のファイルの上から３つのファイル以外は無視してください。
</p>
<table>
<tr><td><a href="shadowmap_fx.html">shadowmap.fx</a></td><td>シェーダの入ったエフェクトファイル</td></tr>
<tr><td><a href="main_h.html">main.h</a></td><td>アプリケーションのヘッダ</td></tr>
<tr><td><a href="main_cpp.html">main.cpp</a></td><td>アプリケーションのソース</td></tr>
<tr><td>　</td><td></td></tr>
<tr><td><a href="d3dapp_h.html">d3dapp.h</a></td><td>アプリケーションの基底クラス</td></tr>
<tr><td><a href="d3dapp_cpp.html">d3dapp.cpp</a></td><td>アプリケーションの基底クラス</td></tr>
<tr><td><a href="dxutil_h.html">dxutil.h</a></td><td>SAFE_RELEASE とかの便利関数</td></tr>
<tr><td><a href="dxutil_cpp.html">dxutil.cpp</a></td><td>SAFE_RELEASE とかの便利関数</td></tr>
<tr><td><a href="d3dutil_h.html">d3dutil.h</a></td><td>カメラとかの便利クラス</td></tr>
<tr><td><a href="d3dutil_cpp.html">d3dutil.cpp</a></td><td>カメラとかの便利クラス</td></tr>
<tr><td><a href="d3denumeration_h.html">d3denumeration.h</a></td><td>デバイス管理の補助</td></tr>
<tr><td><a href="d3denumeration_cpp.html">d3denumeration.cpp</a></td><td>デバイス管理の補助</td></tr>
<tr><td><a href="d3dfile_h.html">d3dfile.h</a></td><td>メッシュの読み込み</td></tr>
<tr><td><a href="d3dfile_cpp.html">d3dfile.cpp</a></td><td>メッシュの読み込み</td></tr>
<tr><td><a href="d3dfont_h.html">d3dfont.h</a></td><td>フォントの描画</td></tr>
<tr><td><a href="d3dfont_cpp.html">d3dfont.cpp</a></td><td>フォントの描画</td></tr>
<tr><td><a href="d3dsettings_h.html">d3dsettings.h</a></td><td>メニューによる設定</td></tr>
<tr><td><a href="d3dsettings_cpp.html">d3dsettings.cpp</a></td><td>メニューによる設定</td></tr>
<tr><td><a href="diutil_h.html">diutil.h</a></td><td>入力管理</td></tr>
<tr><td><a href="diutil_cpp.html">diutil.cpp</a></td><td>入力管理</td></tr>
<tr><td><a href="dmutil_h.html">dmutil.h</a></td><td>音楽管理</td></tr>
<tr><td><a href="dmutil_cpp.html">dmutil.cpp</a></td><td>音楽管理</td></tr>
</table>
<p>
あと、実行ファイル、表示用モデル及び、プロジェクトファイルが入っています。
</p>


<h2>■シェーダ</h2>


<p>
テクスチャフォーマット以外はシャドウマップそのままなので、
適当に解説を進めていきましょう。<br>
シャドウマップは２パスのアルゴリズムなので、エフェクトファイルにパスごとのシェーダの設定をします。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0112:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0113:</font> <font color="cyan">// テクニック</font>
<font color="deepskyblue">0114:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0115:</font> technique TShader
<font color="deepskyblue">0116:</font> {
<font color="deepskyblue">0117:</font>     pass P0
<font color="deepskyblue">0118:</font>     {
<font color="deepskyblue">0119:</font>         <font color="cyan">// シェーダ</font>
<font color="deepskyblue">0120:</font>         VertexShader = compile vs_1_1 VS_pass0();
<font color="deepskyblue">0121:</font>         PixelShader  = &lt;PS_pass0&gt;;
<font color="deepskyblue">0122:</font>     }
<font color="deepskyblue">0123:</font>     pass P1
<font color="deepskyblue">0124:</font>     {
<font color="deepskyblue">0125:</font>         <font color="cyan">// シェーダ</font>
<font color="deepskyblue">0126:</font>         VertexShader = compile vs_1_1 VS_pass1();
<font color="deepskyblue">0127:</font>         PixelShader  = compile ps_2_0 PS_pass1();
<font color="deepskyblue">0128:</font>         
<font color="deepskyblue">0129:</font>         Sampler[0] = (ShadowMapSamp);
<font color="deepskyblue">0130:</font>     }
<font color="deepskyblue">0131:</font> }
</pre>
<p>
１パス目のピクセルシェーダは、アセンブリを使うことにしました。<br>
２パス目に、いよいよシェーダ2.0の登場です。といっても、赤色成分だけを使うのが、
ピクセルシェーダ1.1では、できないからです。
テクスチャフォーマット的を、D3DFMT_R32Fじゃ無くて
D3DFMT_<b>A</b>32F にしてくれれば何も問題なかったのに…。
</p>
<p>
あと、２パス目ではシャドウマップのテクスチャを使うので、
サンプリングステートの設定が必要になります。<br>
必要なことは、テクスチャの名前（ここでは、ShadowMap）と、
あとは、拡大縮小フィルターなどのサンプリング法と、
範囲外のテクスチャ座標の時にクランプするかどうかなどです。
</p>

<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0016:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0017:</font> <font color="cyan">// テクスチャ</font>
<font color="deepskyblue">0018:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0019:</font> texture ShadowMap;
<font color="deepskyblue">0020:</font> sampler ShadowMapSamp = sampler_state
<font color="deepskyblue">0021:</font> {
<font color="deepskyblue">0022:</font>     Texture = &lt;ShadowMap&gt;;
<font color="deepskyblue">0023:</font>     MinFilter = LINEAR;
<font color="deepskyblue">0024:</font>     MagFilter = LINEAR;
<font color="deepskyblue">0025:</font>     MipFilter = NONE;
<font color="deepskyblue">0026:</font> 
<font color="deepskyblue">0027:</font>     AddressU = Clamp;
<font color="deepskyblue">0028:</font>     AddressV = Clamp;
<font color="deepskyblue">0029:</font> };
</pre>
<p>
では、シェーダプログラムを見ていきましょう。<br>
頂点シェーダの出力構造体を次のようにします。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0030:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0031:</font> <font color="cyan">// 頂点シェーダからピクセルシェーダに渡すデータ</font>
<font color="deepskyblue">0032:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0033:</font> <font color="blue">struct</font> VS_OUTPUT
<font color="deepskyblue">0034:</font> {
<font color="deepskyblue">0035:</font>     float4 Pos          : POSITION;
<font color="deepskyblue">0036:</font>     float4 Diffuse      : COLOR0;
<font color="deepskyblue">0037:</font>     float4 Ambient      : COLOR1;
<font color="deepskyblue">0038:</font>     float4 ShadowMapUV  : TEXCOORD0;
<font color="deepskyblue">0039:</font>     float4 Depth        : TEXCOORD1;
<font color="deepskyblue">0040:</font> };
</pre>
<p>
どうも、VS_OUTPUT しか作れなかったので、２つのパスでの出力を同じ構造体にしています。<BR>
もしも、複数の構造体が作れないなら、同じ物体を記述するエフェクトファイルでも、
いくつかに分離するほうが良いかもしれません。
</p>
<p>
１パス目の頂点シェーダでは、ライトから見たカメラ座標系で座標変換して、
その位置を出力構造体の座標として出力すると共に、
スクリーン座標のＺ値をテクスチャに埋め込むために、テクスチャ座標に出力します。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0042:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0043:</font> <font color="cyan">// 1パス目：頂点シェーダプログラム</font>
<font color="deepskyblue">0044:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0045:</font> VS_OUTPUT VS_pass0(
<font color="deepskyblue">0046:</font>       float4 Pos    : POSITION,          <font color="cyan">// モデルの頂点</font>
<font color="deepskyblue">0047:</font>       float3 Normal : NORMAL             <font color="cyan">// モデルの法線</font>
<font color="deepskyblue">0048:</font> ){
<font color="deepskyblue">0049:</font>     VS_OUTPUT Out = (VS_OUTPUT)0;        <font color="cyan">// 出力データ</font>
<font color="deepskyblue">0050:</font>     
<font color="deepskyblue">0051:</font>     <font color="cyan">// 座標変換</font>
<font color="deepskyblue">0052:</font>     float4 pos = mul( Pos, mWLP );
<font color="deepskyblue">0053:</font>     
<font color="deepskyblue">0054:</font>     <font color="cyan">// 位置座標</font>
<font color="deepskyblue">0055:</font>     Out.Pos = pos;
<font color="deepskyblue">0056:</font>     
<font color="deepskyblue">0057:</font>     <font color="cyan">// カメラ座標系での深度をテクスチャに入れる</font>
<font color="deepskyblue">0058:</font>     Out.ShadowMapUV = pos.z / pos.w;
<font color="deepskyblue">0059:</font> 
<font color="deepskyblue">0060:</font>     <font color="blue">return</font> Out;
<font color="deepskyblue">0061:</font> }
</pre>
<p>
ピクセルシェーダでは、受け取ったテクスチャ座標を texcoord 命令を使って、そのままレジスタに格納して、
その値を出力レジスタである、r0にいれます。<br>
asm で始まるコードに、シェーダアセンブラをそのまま書くことができます。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0062:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0063:</font> <font color="cyan">// 1パス目：ピクセルシェーダプログラム</font>
<font color="deepskyblue">0064:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0065:</font> PIXELSHADER PS_pass0 = 
<font color="deepskyblue">0066:</font> asm
<font color="deepskyblue">0067:</font> {
<font color="deepskyblue">0068:</font>     ps.1.1
<font color="deepskyblue">0069:</font>     
<font color="deepskyblue">0070:</font>     texcoord t0
<font color="deepskyblue">0071:</font>     
<font color="deepskyblue">0072:</font>     mov r0, t0  <font color="cyan">// テクスチャ座標を色として出力する</font>
<font color="deepskyblue">0073:</font> };
</pre>
<p>
２パス目では、シャドウマップをオブジェクトに貼り付けます。<br>
今度の座用変換は、普通の座標変換です。<br>
光源計算は、Lambert 拡散で、影になった部分を環境色にしますので、
ピクセルシェーダに環境色を拡散色を別々に送ります。<br>
後は、先ほどのテクスチャを張るための座標変換を行い、求めたシャドウマップのテクスチャ座標と、
比較のために、先ほどと同じ様に求めた深度を（縞縞模様を防ぐバイアスをかませて）ピクセルシェーダに送ります。<br>
このバイアスが浮動小数点数フォーマットの時には減らせるかなと思ったのですが、
やってみると、フォーマットの違いはありませんでした。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0074:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0075:</font> <font color="cyan">// 2パス目：頂点シェーダプログラム</font>
<font color="deepskyblue">0076:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0077:</font> VS_OUTPUT VS_pass1(
<font color="deepskyblue">0078:</font>       float4 Pos    : POSITION,          <font color="cyan">// モデルの頂点</font>
<font color="deepskyblue">0079:</font>       float3 Normal : NORMAL             <font color="cyan">// モデルの法線</font>
<font color="deepskyblue">0080:</font> ){
<font color="deepskyblue">0081:</font>     VS_OUTPUT Out = (VS_OUTPUT)0;        <font color="cyan">// 出力データ</font>
<font color="deepskyblue">0082:</font>     float4  uv;
<font color="deepskyblue">0083:</font>     
<font color="deepskyblue">0084:</font>     <font color="cyan">// 座標変換</font>
<font color="deepskyblue">0085:</font>     Out.Pos = mul(Pos, mWVP);
<font color="deepskyblue">0086:</font>     <font color="cyan">// 色</font>
<font color="deepskyblue">0087:</font>     Out.Diffuse = vCol * max( dot(vLightDir, Normal), 0);<font color="cyan">// 拡散色</font>
<font color="deepskyblue">0088:</font>     Out.Ambient = vCol * 0.3f;                     <font color="cyan">// 環境色</font>
<font color="deepskyblue">0089:</font>     
<font color="deepskyblue">0090:</font>     <font color="cyan">// テクスチャ座標</font>
<font color="deepskyblue">0091:</font>     uv = mul(Pos, mWLPB);
<font color="deepskyblue">0092:</font>     Out.ShadowMapUV = uv;
<font color="deepskyblue">0093:</font>     uv = mul(Pos, mWLP);
<font color="deepskyblue">0094:</font>     Out.Depth       = uv.z / uv.w-0.003;
<font color="deepskyblue">0095:</font>         
<font color="deepskyblue">0096:</font>     <font color="blue">return</font> Out;
<font color="deepskyblue">0097:</font> }
</pre>
<p>
ピクセルシェーダでは、透視変換しつつテクスチャの読み込みをして（これもシェーダ2.0の機能ですね）。<br>
３項演算子?:で、影になっているか判定して、最後の色として出力します。
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0098:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0099:</font> <font color="cyan">// 2パス目：ピクセルシェーダプログラム</font>
<font color="deepskyblue">0100:</font> <font color="cyan">// -------------------------------------------------------------</font>
<font color="deepskyblue">0101:</font> float4 PS_pass1(VS_OUTPUT In) : COLOR
<font color="deepskyblue">0102:</font> {   
<font color="deepskyblue">0103:</font>     float4 Color = In.Ambient;
<font color="deepskyblue">0104:</font>     float4 zero = {0,0,0,0};
<font color="deepskyblue">0105:</font>     
<font color="deepskyblue">0106:</font>     <font color="blue">float</font>  shadow_map = tex2Dproj( ShadowMapSamp, In.ShadowMapUV ).x;
<font color="deepskyblue">0107:</font>     
<font color="deepskyblue">0108:</font>     Color += (shadow_map &lt; In.Depth.z) ? zero : In.Diffuse;
<font color="deepskyblue">0109:</font> 
<font color="deepskyblue">0110:</font>     <font color="blue">return</font> Color;
<font color="deepskyblue">0111:</font> }  
</pre>
<p>
あと、書き忘れましたが、グローバル変数
</p>
<pre class="CodeBlock">
shadowmap.fx
<font color="deepskyblue">0010:</font> float4x4 mWVP;      <font color="cyan">// ローカルから射影空間への座標変換</font>
<font color="deepskyblue">0011:</font> float4x4 mWLP;      <font color="cyan">// ローカルから射影空間への座標変換</font>
<font color="deepskyblue">0012:</font> float4x4 mWLPB;     <font color="cyan">// テクスチャ座標系への射影</font>
<font color="deepskyblue">0013:</font> float4   vCol;      <font color="cyan">// メッシュの色</font>
<font color="deepskyblue">0014:</font> float4   vLightDir; <font color="cyan">// ライトの方向</font>
</pre>
<p>
を使いました。
</p>


<h2>■オブジェクト</h2>


<p>
シャドウマップ使うためのオブジェクトは、エフェクトファイルのオブジェクトおよび、
グローバル変数のハンドルオブジェクトが必要になります。<br>
実際のレンダリングには、それ以外にも、モデルを表示するメッシュのクラス（d3dfile.hのものを使用）や、
シャドウマップのためのテクスチャや深度バッファが必要になります。
座標変換のための行列やライトの位置も持ちます。
</p>
<pre class="CodeBlock">
main.h
<font color="deepskyblue">0032:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0033:</font> <font color="cyan">// Name: class CMyD3DApplication</font>
<font color="deepskyblue">0034:</font> <font color="cyan">// Desc: Application class. The base class (CD3DApplication) provides the </font>
<font color="deepskyblue">0035:</font> <font color="cyan">//       generic functionality needed in all Direct3D samples. CMyD3DApplication </font>
<font color="deepskyblue">0036:</font> <font color="cyan">//       adds functionality specific to this sample program.</font>
<font color="deepskyblue">0037:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0038:</font> <font color="blue">class</font> CMyD3DApplication : <font color="blue">public</font> CD3DApplication
<font color="deepskyblue">0039:</font> {
<font color="deepskyblue">0040:</font>     CD3DMesh                *m_pMeshCar;
<font color="deepskyblue">0041:</font>     CD3DMesh                *m_pMeshChess;
<font color="deepskyblue">0042:</font>             
<font color="deepskyblue">0043:</font>     <font color="cyan">// シェーダ</font>
<font color="deepskyblue">0044:</font>     LPD3DXEFFECT     m_pFx;     <font color="cyan">// シェーダが書かれたエフェクト</font>
<font color="deepskyblue">0045:</font>     D3DXHANDLE       m_hmWVP;   <font color="cyan">// ワールド×ビュー×射影行列</font>
<font color="deepskyblue">0046:</font>     D3DXHANDLE       m_hmWLP;   <font color="cyan">// ライト方向からの変換行列</font>
<font color="deepskyblue">0047:</font>     D3DXHANDLE       m_hmWLPB;  <font color="cyan">// ライト方向からの変換行列</font>
<font color="deepskyblue">0048:</font>     D3DXHANDLE       m_hvCol;   <font color="cyan">// メッシュの色</font>
<font color="deepskyblue">0049:</font>     D3DXHANDLE       m_hvDir;   <font color="cyan">// ライトの方向</font>
<font color="deepskyblue">0050:</font> 
<font color="deepskyblue">0051:</font> 
<font color="deepskyblue">0052:</font>     <font color="cyan">// シャドウマップ</font>
<font color="deepskyblue">0053:</font>     LPDIRECT3DTEXTURE9      m_pShadowMap;
<font color="deepskyblue">0054:</font>     LPDIRECT3DSURFACE9      m_pShadowMapSurf;
<font color="deepskyblue">0055:</font>     LPDIRECT3DSURFACE9      m_pShadowMapZ;
<font color="deepskyblue">0056:</font> 
<font color="deepskyblue">0057:</font>     <font color="cyan">// 通常の座標変換行列</font>
<font color="deepskyblue">0058:</font>     D3DXMATRIX              m_mWorld;
<font color="deepskyblue">0059:</font>     D3DXMATRIX              m_mView;
<font color="deepskyblue">0060:</font>     D3DXMATRIX              m_mProj;
<font color="deepskyblue">0061:</font>     D3DXMATRIX              m_mLightVP;
<font color="deepskyblue">0062:</font> 
<font color="deepskyblue">0063:</font>     D3DXVECTOR3             m_LighPos;      <font color="cyan">// 光源の方向</font>
中略
<font color="deepskyblue">0073:</font> 
<font color="deepskyblue">0074:</font>     VOID DrawModel( <font color="blue">int</font> pass ); <font color="cyan">// 各パスで呼ばれるモデルの描画</font>
後略
</pre>


<h2>■能力チェック</h2>


<p>
頂点シェーダやピクセルシェーダを使うときには、
シェーダのバージョンを気にする必要があります。<br>
今回は、頂点シェーダ1.1と、ピクセルシェーダ2.0をつかうので、
それらの条件を満たしているか調べます。<br>
AppWizard を使ったときには、ConfirmDevice が、能力を調べるときなので、
この関数にチェックルーチンを仕込みます。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0154:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0155:</font> <font color="cyan">// Name: ConfirmDevice()</font>
<font color="deepskyblue">0156:</font> <font color="cyan">// Desc: Called during device initialization, this code checks the display device</font>
<font color="deepskyblue">0157:</font> <font color="cyan">//       for some minimum set of capabilities</font>
<font color="deepskyblue">0158:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0159:</font> HRESULT CMyD3DApplication::ConfirmDevice( D3DCAPS9* pCaps, DWORD dwBehavior,
<font color="deepskyblue">0160:</font>                                           D3DFORMAT Format )
<font color="deepskyblue">0161:</font> {
<font color="deepskyblue">0162:</font>     UNREFERENCED_PARAMETER( Format );
<font color="deepskyblue">0163:</font>     UNREFERENCED_PARAMETER( dwBehavior );
<font color="deepskyblue">0164:</font>     UNREFERENCED_PARAMETER( pCaps );
<font color="deepskyblue">0165:</font>     
<font color="deepskyblue">0166:</font>     BOOL bCapsAcceptable;
<font color="deepskyblue">0167:</font> 
<font color="deepskyblue">0168:</font>     <font color="cyan">// TODO: Perform checks to see if these display caps are acceptable.</font>
<font color="deepskyblue">0169:</font>     bCapsAcceptable = TRUE;
<font color="deepskyblue">0170:</font> 
<font color="deepskyblue">0171:</font>     <font color="cyan">// ピクセルシェーダバージョンチェック</font>
<font color="deepskyblue">0172:</font>     <font color="blue">if</font>( pCaps-&gt;PixelShaderVersion &lt; D3DPS_VERSION(2,0) )
<font color="deepskyblue">0173:</font>         bCapsAcceptable = FALSE;
<font color="deepskyblue">0174:</font> 
<font color="deepskyblue">0175:</font>     <font color="cyan">// 頂点シェーダバージョンが上位かソフトウェア頂点処理</font>
<font color="deepskyblue">0176:</font>     <font color="blue">if</font>( pCaps-&gt;VertexShaderVersion &lt; D3DVS_VERSION(1,1) )
<font color="deepskyblue">0177:</font>         <font color="blue">if</font>( (dwBehavior &amp; D3DCREATE_SOFTWARE_VERTEXPROCESSING ) == 0 )
<font color="deepskyblue">0178:</font>             bCapsAcceptable = FALSE;
<font color="deepskyblue">0179:</font> 
<font color="deepskyblue">0180:</font>     <font color="blue">if</font>( bCapsAcceptable )         
<font color="deepskyblue">0181:</font>         <font color="blue">return</font> S_OK;
<font color="deepskyblue">0182:</font>     <font color="blue">else</font>
<font color="deepskyblue">0183:</font>         <font color="blue">return</font> E_FAIL;
<font color="deepskyblue">0184:</font> }
</pre>




<h2>■初期化</h2>


<p>
デバイスが使えることが分かったら、いよいよ初期化して使います。<br>
最初だけ初期化すればいいものに、メッシュやエフェクトファイルの読み込みがあります。<br>
メッシュの初期化は、フレームワークの方に読み込みメソッドがあるので、そちらを使用します。<br>
シェーダは、D3DXCreateEffectFromFile で読み込みます。<br>
シェーダ内のグローバル変数は、GetParameterByName で、名前を使ってハンドルが得られるようなので、
そちらを使いました。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0221:</font> HRESULT CMyD3DApplication::InitDeviceObjects()
<font color="deepskyblue">0222:</font> {
<font color="deepskyblue">0223:</font>     HRESULT hr;
<font color="deepskyblue">0224:</font> 
<font color="deepskyblue">0225:</font>     <font color="cyan">// 車の読み込み</font>
<font color="deepskyblue">0226:</font>     <font color="blue">if</font>( FAILED( hr = m_pMeshCar-&gt;Create( m_pd3dDevice, _T("<font color="blue">car.x</font>") )))
<font color="deepskyblue">0227:</font>         <font color="blue">return</font> DXTRACE_ERR( "<font color="blue">LoadCar</font>", hr );
<font color="deepskyblue">0228:</font>     m_pMeshCar-&gt;UseMeshMaterials(FALSE);<font color="cyan">// レンダリング時にテクスチャの設定をしない</font>
<font color="deepskyblue">0229:</font>     <font color="cyan">// 地面の読み込み</font>
<font color="deepskyblue">0230:</font>     <font color="blue">if</font>( FAILED( hr = m_pMeshChess-&gt;Create( m_pd3dDevice, _T("<font color="blue">chess.x</font>") )))
<font color="deepskyblue">0231:</font>         <font color="blue">return</font> DXTRACE_ERR( "<font color="blue">LoadChess</font>", hr );
<font color="deepskyblue">0232:</font>     m_pMeshChess-&gt;UseMeshMaterials(FALSE);<font color="cyan">// レンダリング時にテクスチャの設定をしない</font>
<font color="deepskyblue">0233:</font> 
<font color="deepskyblue">0237:</font>     <font color="cyan">// シェーダの読み込み</font>
<font color="deepskyblue">0238:</font>     <font color="blue">if</font>( FAILED( D3DXCreateEffectFromFile( m_pd3dDevice, "<font color="blue">shadowmap.fx</font>", NULL, NULL, 
<font color="deepskyblue">0239:</font>                                         0, NULL, &amp;m_pFx, NULL ) ) ) <font color="blue">return</font> E_FAIL;
<font color="deepskyblue">0240:</font>     m_hmWVP = m_pFx-&gt;GetParameterByName( NULL, "<font color="blue">mWVP</font>" );
<font color="deepskyblue">0241:</font>     m_hmWLP = m_pFx-&gt;GetParameterByName( NULL, "<font color="blue">mWLP</font>" );
<font color="deepskyblue">0242:</font>     m_hmWLPB= m_pFx-&gt;GetParameterByName( NULL, "<font color="blue">mWLPB</font>" );
<font color="deepskyblue">0243:</font>     m_hvCol = m_pFx-&gt;GetParameterByName( NULL, "<font color="blue">vCol</font>" );
<font color="deepskyblue">0244:</font>     m_hvDir = m_pFx-&gt;GetParameterByName( NULL, "<font color="blue">vLightDir</font>" );
<font color="deepskyblue">0245:</font> 
<font color="deepskyblue">0246:</font>     <font color="blue">return</font> S_OK;
<font color="deepskyblue">0247:</font> }
</pre>

<p>
あと、シャドウマップの初期化も必要です。<br>
CreateTexture で、生成したり、この辺は、DirectX8 と同じです。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0026:</font> <font color="blue">#define</font> SHADOW_MAP_FORMAT D3DFMT_R32F
<font color="deepskyblue">0028:</font> <font color="blue">#define</font> SHADOW_MAP_SIZE   2048
<font color="deepskyblue">0308:</font>     <font color="cyan">// シャドウマップの生成</font>
<font color="deepskyblue">0309:</font>     <font color="blue">if</font> (FAILED(m_pd3dDevice-&gt;CreateTexture(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, 1, 
<font color="deepskyblue">0310:</font>         D3DUSAGE_RENDERTARGET, SHADOW_MAP_FORMAT, D3DPOOL_DEFAULT, &amp;m_pShadowMap, NULL)))
<font color="deepskyblue">0311:</font>         <font color="blue">return</font> E_FAIL;
<font color="deepskyblue">0312:</font>     <font color="blue">if</font> (FAILED(m_pShadowMap-&gt;GetSurfaceLevel(0, &amp;m_pShadowMapSurf)))
<font color="deepskyblue">0313:</font>         <font color="blue">return</font> E_FAIL;
<font color="deepskyblue">0314:</font>     <font color="blue">if</font> (FAILED(m_pd3dDevice-&gt;CreateDepthStencilSurface(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, 
<font color="deepskyblue">0315:</font>         D3DFMT_D16, D3DMULTISAMPLE_NONE, 0, TRUE, &amp;m_pShadowMapZ, NULL)))
<font color="deepskyblue">0316:</font>         <font color="blue">return</font> E_FAIL;
</pre>




<h2>■描画</h2>


<p>
さて、いよいよ描画です。<br>
最初にライトからみた射影空間への行列を作ります。<br>
それ以外の行列は、ほかであらかじめ作っておきます。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0497:</font> HRESULT CMyD3DApplication::Render()
<font color="deepskyblue">0498:</font> {
<font color="deepskyblue">0499:</font>     D3DXMATRIX mLP, mView, mProj;
<font color="deepskyblue">0500:</font>     LPDIRECT3DSURFACE9 pOldBackBuffer, pOldZBuffer;
<font color="deepskyblue">0501:</font>     D3DVIEWPORT9 oldViewport;
<font color="deepskyblue">0502:</font> 
<font color="deepskyblue">0503:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0504:</font>     <font color="cyan">// 行列の作成</font>
<font color="deepskyblue">0505:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0506:</font>     <font color="cyan">// ライト方向から見た射影空間への行列</font>
<font color="deepskyblue">0507:</font>     D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
<font color="deepskyblue">0508:</font>     D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
<font color="deepskyblue">0509:</font>     D3DXMatrixLookAtLH( &amp;mView, &amp;m_LighPos, &amp;vLookatPt, &amp;vUpVec );
<font color="deepskyblue">0510:</font>     D3DXMatrixPerspectiveFovLH( &amp;mProj
<font color="deepskyblue">0511:</font>                             , 0.21f*D3DX_PI     <font color="cyan">// 視野角</font>
<font color="deepskyblue">0512:</font>                             , 1.0f              <font color="cyan">// アスペクト比</font>
<font color="deepskyblue">0513:</font>                             , 5.0f, 12.0f );    <font color="cyan">// near far</font>
<font color="deepskyblue">0514:</font>     m_mLightVP = mView * mProj;
</pre>
<p>
次に、描画を開始します。<br>
BeginScene の後に、エフェクトファイルによるシェーダのレンダリングに切り替えます。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0516:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0517:</font>     <font color="cyan">// 描画</font>
<font color="deepskyblue">0518:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0519:</font>     <font color="blue">if</font>( SUCCEEDED( m_pd3dDevice-&gt;BeginScene() ) )
<font color="deepskyblue">0520:</font>     {
<font color="deepskyblue">0521:</font>         <font color="blue">if</font>( m_pFx != NULL ) 
<font color="deepskyblue">0522:</font>         {
<font color="deepskyblue">0523:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0524:</font>             <font color="cyan">// シェーダの設定</font>
<font color="deepskyblue">0525:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0526:</font>             D3DXHANDLE hTechnique = m_pFx-&gt;GetTechniqueByName( "<font color="blue">TShader</font>" );
<font color="deepskyblue">0527:</font>             m_pFx-&gt;SetTechnique( hTechnique );
<font color="deepskyblue">0528:</font>             m_pFx-&gt;Begin( NULL, 0 );
</pre>
<p>
次に、レンダリングターゲットをシャドウマップに切り替えます。<br>
その後は、エフェクトファイルの１つめのパス m_pFx-&gt;Pass(0) でモデルを描画します。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0530:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0531:</font>             <font color="cyan">// レンダリングターゲットの保存</font>
<font color="deepskyblue">0532:</font>             <font color="cyan">//--------------------------------------------------------------------------</font>
<font color="deepskyblue">0533:</font>             m_pd3dDevice-&gt;GetRenderTarget(0, &amp;pOldBackBuffer);
<font color="deepskyblue">0534:</font>             m_pd3dDevice-&gt;GetDepthStencilSurface(&amp;pOldZBuffer);
<font color="deepskyblue">0535:</font>             m_pd3dDevice-&gt;GetViewport(&amp;oldViewport);
<font color="deepskyblue">0536:</font> 
<font color="deepskyblue">0537:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0538:</font>             <font color="cyan">// レンダリングターゲットの変更</font>
<font color="deepskyblue">0539:</font>             <font color="cyan">//--------------------------------------------------------------------------</font>
<font color="deepskyblue">0540:</font>             m_pd3dDevice-&gt;SetRenderTarget(0, m_pShadowMapSurf);
<font color="deepskyblue">0541:</font>             m_pd3dDevice-&gt;SetDepthStencilSurface(m_pShadowMapZ);
<font color="deepskyblue">0542:</font>             <font color="cyan">// ビューポートの変更    x y       width         height       minz maxz</font>
<font color="deepskyblue">0543:</font>             D3DVIEWPORT9 viewport = {0,0, SHADOW_MAP_SIZE,SHADOW_MAP_SIZE,0.0f,1.0f};
<font color="deepskyblue">0544:</font>             m_pd3dDevice-&gt;SetViewport(&amp;viewport);
<font color="deepskyblue">0545:</font> 
<font color="deepskyblue">0546:</font>             <font color="cyan">// シャドウマップのクリア</font>
<font color="deepskyblue">0547:</font>             m_pd3dDevice-&gt;Clear(0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
<font color="deepskyblue">0548:</font>                                 0xFFFFFFFF, 1.0f, 0L);
<font color="deepskyblue">0549:</font> 
<font color="deepskyblue">0550:</font>             <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0551:</font>             <font color="cyan">// 1パス目:シャドウマップの作成</font>
<font color="deepskyblue">0552:</font>             <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0553:</font>             m_pFx-&gt;Pass( 0 );
<font color="deepskyblue">0554:</font>             DrawModel( 0 );
</pre>
<p>
２パス目では、レンダリングターゲットをフレームバッファに戻した後に、
テクスチャを設定してから、２パス目のm_pFx-&gt;Pass( 1 )で描画します。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0556:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0557:</font>             <font color="cyan">// レンダリングターゲットを元に戻す</font>
<font color="deepskyblue">0558:</font>             <font color="cyan">//--------------------------------------------------------------------------</font>
<font color="deepskyblue">0559:</font>             m_pd3dDevice-&gt;SetRenderTarget(0, pOldBackBuffer);
<font color="deepskyblue">0560:</font>             m_pd3dDevice-&gt;SetDepthStencilSurface(pOldZBuffer);
<font color="deepskyblue">0561:</font>             m_pd3dDevice-&gt;SetViewport(&amp;oldViewport);
<font color="deepskyblue">0562:</font>             pOldBackBuffer-&gt;Release();
<font color="deepskyblue">0563:</font>             pOldZBuffer-&gt;Release();
<font color="deepskyblue">0564:</font> 
<font color="deepskyblue">0565:</font>             <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0566:</font>             <font color="cyan">// 2パス目:シーンの描画</font>
<font color="deepskyblue">0567:</font>             <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0568:</font>             <font color="cyan">// バッファのクリア</font>
<font color="deepskyblue">0569:</font>             m_pd3dDevice-&gt;Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
<font color="deepskyblue">0570:</font>                                 0x00404080, 1.0f, 0L );
<font color="deepskyblue">0571:</font> 
<font color="deepskyblue">0572:</font>             <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0573:</font>             <font color="cyan">// 描画</font>
<font color="deepskyblue">0574:</font>             <font color="cyan">//--------------------------------------------------------------------------</font>
<font color="deepskyblue">0575:</font>             m_pFx-&gt;SetTexture("<font color="blue">ShadowMap</font>", m_pShadowMap);<font color="cyan">// テクスチャの設定</font>
<font color="deepskyblue">0576:</font>             m_pFx-&gt;Pass( 1 );
<font color="deepskyblue">0577:</font>             DrawModel( 1 );
</pre>
<p>
最後に、エフェクトファイルによるレンダリングを終了して、EndScene で閉じます。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0579:</font>             m_pFx-&gt;End();
<font color="deepskyblue">0580:</font>         }
<font color="deepskyblue">0581:</font> 
<font color="deepskyblue">0606:</font>         <font color="cyan">// 描画の終了</font>
<font color="deepskyblue">0607:</font>         m_pd3dDevice-&gt;EndScene();
<font color="deepskyblue">0608:</font>     }
<font color="deepskyblue">0609:</font> 
<font color="deepskyblue">0610:</font>     <font color="blue">return</font> S_OK;
<font color="deepskyblue">0611:</font> }
</pre>


<h2>■オブジェクトのレンダリング</h2>



<p>
モデルの描画では、シャドウマップを張るために、射影空間からへクスチャ座標に変換するための行列
mScaleBias を作って、モデルを描画します。<br>

</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0388:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0389:</font> <font color="cyan">// 各モデルの描画</font>
<font color="deepskyblue">0390:</font> <font color="cyan">//-----------------------------------------------------------------------------</font>
<font color="deepskyblue">0391:</font> VOID CMyD3DApplication::DrawModel( <font color="blue">int</font> pass )
<font color="deepskyblue">0392:</font> {
<font color="deepskyblue">0393:</font>     D3DXMATRIX m, mL, mS, mT, mR;
<font color="deepskyblue">0394:</font>     D3DXVECTOR3 vDir;
<font color="deepskyblue">0395:</font>     D3DXVECTOR4 v;
<font color="deepskyblue">0396:</font>     D3DMATERIAL9 *pMtrl;
<font color="deepskyblue">0397:</font>     DWORD i;
<font color="deepskyblue">0398:</font>     
<font color="deepskyblue">0399:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0400:</font>     <font color="cyan">// 行列の生成</font>
<font color="deepskyblue">0401:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0402:</font>     D3DXMATRIX mVP = m_mWorld * m_mView * m_mProj;
<font color="deepskyblue">0403:</font>     
<font color="deepskyblue">0404:</font>     <font color="cyan">// 射影空間から、テクスチャーの空間に変換する</font>
<font color="deepskyblue">0405:</font>     <font color="blue">float</font> fOffsetX = 0.5f + (0.5f / (<font color="blue">float</font>)SHADOW_MAP_SIZE);
<font color="deepskyblue">0406:</font>     <font color="blue">float</font> fOffsetY = 0.5f + (0.5f / (<font color="blue">float</font>)SHADOW_MAP_SIZE);
<font color="deepskyblue">0407:</font>     D3DXMATRIX mScaleBias(  0.5f,     0.0f,     0.0f,   0.0f,
<font color="deepskyblue">0408:</font>                             0.0f,    -0.5f,     0.0f,   0.0f,
<font color="deepskyblue">0409:</font>                             0.0f,     0.0f,     0.0f,   0.0f,
<font color="deepskyblue">0410:</font>                             fOffsetX, fOffsetY, 0.0f,   1.0f );
</pre>
<p>
モデルの描画には、パスごとに必要な行列やベクトルを設定して描画します。<br>
メッシュの部位ごとに色を塗るので、DrawSubset を別々に呼びます。
</p>
<pre class="CodeBlock">
main.cpp
<font color="deepskyblue">0412:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0413:</font>     <font color="cyan">// 車</font>
<font color="deepskyblue">0414:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0415:</font>     <font color="cyan">// ワールド行列の生成</font>
<font color="deepskyblue">0416:</font>     D3DXMatrixScaling( &amp;mS, 0.05f, 0.05f, 0.05f );
<font color="deepskyblue">0417:</font>     D3DXMatrixTranslation( &amp;mT, 1.0f, 0.0f ,0.0f );
<font color="deepskyblue">0419:</font>     D3DXMatrixRotationY( &amp;mR, m_fTime );
<font color="deepskyblue">0420:</font>     mL = mS * mT * mR;
<font color="deepskyblue">0421:</font>     <font color="blue">switch</font>(pass){
<font color="deepskyblue">0422:</font>     <font color="blue">case</font> 0:<font color="cyan">// シャドウマップの作成</font>
<font color="deepskyblue">0423:</font>         m = mL * m_mLightVP;
<font color="deepskyblue">0424:</font>         <font color="blue">if</font>( m_hmWLP != NULL ) m_pFx-&gt;SetMatrix( m_hmWLP, &amp;m );
<font color="deepskyblue">0425:</font>         m_pMeshCar  -&gt;Render( m_pd3dDevice );<font color="cyan">// 描画</font>
<font color="deepskyblue">0426:</font>         <font color="blue">break</font>;
<font color="deepskyblue">0427:</font>     <font color="blue">default</font>:<font color="cyan">// シーンの描画</font>
<font color="deepskyblue">0428:</font>         m = mL * mVP;
<font color="deepskyblue">0429:</font>         <font color="blue">if</font>( m_hmWVP != NULL ) m_pFx-&gt;SetMatrix( m_hmWVP, &amp;m );
<font color="deepskyblue">0430:</font>         m = mL * m_mLightVP;
<font color="deepskyblue">0431:</font>         <font color="blue">if</font>( m_hmWLP != NULL ) m_pFx-&gt;SetMatrix( m_hmWLP, &amp;m );
<font color="deepskyblue">0432:</font>         m = m * mScaleBias;
<font color="deepskyblue">0433:</font>         <font color="blue">if</font>( m_hmWLPB != NULL ) m_pFx-&gt;SetMatrix( m_hmWLPB, &amp;m );
<font color="deepskyblue">0434:</font>         D3DXMatrixInverse( &amp;m, NULL, &amp;mL);
<font color="deepskyblue">0435:</font>         D3DXVec3Transform( &amp;v, &amp;m_LighPos, &amp;m );
<font color="deepskyblue">0436:</font>         D3DXVec4Normalize( &amp;v, &amp;v );v.w = 0;
<font color="deepskyblue">0437:</font>         <font color="blue">if</font>( m_hvDir != NULL ) m_pFx-&gt;SetVector( m_hvDir, &amp;v );
<font color="deepskyblue">0438:</font> 
<font color="deepskyblue">0439:</font>         pMtrl = m_pMeshCar-&gt;m_pMaterials;
<font color="deepskyblue">0440:</font>         <font color="blue">for</font>( i=0; i&lt;m_pMeshCar-&gt;m_dwNumMaterials; i++ ) {
<font color="deepskyblue">0441:</font>             v.x = pMtrl-&gt;Diffuse.r;
<font color="deepskyblue">0442:</font>             v.y = pMtrl-&gt;Diffuse.g;
<font color="deepskyblue">0443:</font>             v.z = pMtrl-&gt;Diffuse.b;
<font color="deepskyblue">0444:</font>             v.w = pMtrl-&gt;Diffuse.a;
<font color="deepskyblue">0445:</font>             <font color="blue">if</font>( m_hvCol != NULL ) m_pFx-&gt;SetVector( m_hvCol, &amp;v );
<font color="deepskyblue">0446:</font>             m_pMeshCar-&gt;m_pLocalMesh-&gt;DrawSubset( i );  <font color="cyan">// 描画</font>
<font color="deepskyblue">0447:</font>             pMtrl++;
<font color="deepskyblue">0448:</font>         }
<font color="deepskyblue">0449:</font>         <font color="blue">break</font>;
<font color="deepskyblue">0450:</font>     }
<font color="deepskyblue">0451:</font> 
<font color="deepskyblue">0452:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
<font color="deepskyblue">0453:</font>     <font color="cyan">// 地形</font>
<font color="deepskyblue">0454:</font>     <font color="cyan">//-------------------------------------------------------------------------</font>
中略
<font color="deepskyblue">0488:</font> }
</pre>



<h2>■最後に</h2>


<p>
うーん、違いが出なかったところが残念でした。<br>
今回はテクスチャの解像度が画質に大きく影響しました。<br>
それにしても、256ビットでも綺麗に出たのは不思議ですね。<br>
昔はもっとバイアスを大きくしないと上手くいかなかった気がするのですが…
</p>

</div>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<BR CLEAR=ALL>
<center>
<hr>
<p><a href="../index.html">もどる</a></p>
<p><a href="mailto:imagire@gmail.com">imagire@gmail.com</a></p>
</center>

</body>
</html>